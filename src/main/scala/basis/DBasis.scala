package basis

class DBasis extends Basis {

  override def update(newSet: Set[String]) = {
    super.update(newSet)
    val broken = this.brokenImplications(newSet)
    val unbroken = this.unbrokenImplications(newSet)
    val partialOrder = this.binary
    val nonBinaryPart = this.nonBinary
    val updatedPartialOrder = unbroken & partialOrder

    // Step 1: Calculate target set
    val targetSet = targets(partialOrder, newSet)

    // Step 2: Lift implications which contain elements of the target set
    val liftable = nonBinaryPart.filter(_.premise.intersect(targetSet).nonEmpty)
    val lifted = liftable.flatMap(imp => lift(targetSet, partialOrder, newSet, imp))

    // Step 3: Check lifted implications for refinements
    val possibleRefinements = (updatedPartialOrder | nonBinaryPart | lifted).filter(_.premise.intersect(newSet).nonEmpty)
    val filteredLifted = filterRefinements(updatedPartialOrder, lifted, possibleRefinements)

    // Step 4: Perform body-building formula on broken implications from original basis and lift
    val unbrokenLifted = filteredLifted.filter(_.holdsOn(newSet))
    val brokenLifted = filteredLifted &~ unbrokenLifted

    val updated: Set[Implication] = (broken | brokenLifted).flatMap { imp =>
      val ineligibleExtensions = newSet | upSet(updatedPartialOrder, imp.conclusion) // A union d_{uparrow A}
      val extensions = minimalElements(updatedPartialOrder, this.baseSet &~ ineligibleExtensions)
      extensions.map( ext =>
        extend(updatedPartialOrder, imp, Set(ext))
      )
    }

    // Step 5: Filter out possible refinements generated by body-building
    val filteredUpdatedAndLifted = filterRefinements(updatedPartialOrder, updated | unbrokenLifted, updated | unbroken | unbrokenLifted)

    this.basis = filteredUpdatedAndLifted | filterRefinements(updatedPartialOrder, unbroken, filteredUpdatedAndLifted)
  }

  def targets(partialOrder: Set[Implication], newSet: Set[String]) =
    partialOrder.filterNot(_.holdsOn(newSet)).flatMap(_.conclusion) &~ newSet

  def lift(targetSet: Set[String], partialOrder: Set[Implication], newSet: Set[String], imp: Implication): Set[Implication] = {
    if (imp.premise.forall(elem => !targetSet.contains(elem))) // no element of C is in the target set
      Set(imp)
    else { // some element of C is in the target set
      val removableElements = imp.premise.intersect(targetSet)
      val remainingElements = imp.premise &~ removableElements
      // want all implications with at least one of these elements replaced
      val replacements = removableElements.map{ removable =>
        ((minStrictUpSet(partialOrder, newSet, Set(removable))) &~ imp.conclusion) + removable
      }
      val premises = product(replacements)
      val lifted = premises.map(prem => Implication(remainingElements | prem, imp.conclusion)) - imp // one combination will be original implication

      lifted.map(imp =>
        reducePremise(partialOrder.filter(_.holdsOn(newSet)), imp)
      )
    }
  }

  /** Implementation of A_x from paper. Finds the set of elements directly above x in the partial order */
  def minStrictUpSet(partialOrder: Set[Implication], newSet: Set[String], elements: Set[String]): Set[String] =
    minimalElements(partialOrder, (upSet(partialOrder, elements) &~ elements) & newSet)

  /** Filter out elements which are not minimal with respect to the partial order */
  def minimalElements(partialOrder: Set[Implication], elements: Set[String]) =
    elements.filterNot(elem1 =>
      (elements - elem1).exists(elem2 =>
        greaterThanOrEqualTo(partialOrder, Set(elem1), Set(elem2))
      )
    )

  /**
   * Reduces the premise of an implication with respect to the partial order.
   * If the premise contains x and y where x is in the order ideal of y,
   * then we can remove x from the premise to get a stronger implication
   */
  def reducePremise(partialOrder: Set[Implication], imp: Implication): Implication = {
    val reducedPremise =
      imp.premise.filterNot(x =>
        (imp.premise - x).exists(y =>
          ideal(partialOrder, Set(y)).contains(x)
        )
      )

    Implication(reducedPremise, imp.conclusion)
  }

  /** For sets x and y greaterThanOrEqualTo(x, y) is True if x -> y is in Sigma^b (binary) */
  def greaterThanOrEqualTo(partialOrder: Set[Implication], x: Set[String], y: Set[String]) =
    partialOrder.contains(Implication(x, y))

  def filterRefinements(partialOrder: Set[Implication], candidates: Set[Implication], existing: Set[Implication]) =
    candidates.filterNot( imp1 =>
      (existing - imp1).exists(imp2 =>
        refines(partialOrder, imp2, imp1)
      )
    )

  /** If imp1 << imp2, true otherwise false */
  def refines(partialOrder: Set[Implication], imp1: Implication, imp2: Implication): Boolean =
    if (imp1.conclusion.equals(imp2.conclusion))
      imp1.premise.subsetOf(imp2.premise | ideal(partialOrder, imp2.premise))
    else
      false

  def extend(partialOrder: Set[Implication], imp: Implication, ext: Set[String]) = {
    val extensionIdeal = ideal(partialOrder, ext)
    if (imp.premise.intersect(extensionIdeal).nonEmpty)
      Implication((imp.premise &~ extensionIdeal) | ext, imp.conclusion)
    else
      Implication(imp.premise | ext, imp.conclusion)
  }

  /* This is not entirely correct; produces incorrect CDB for some examples */
  def toCdb(): CanonicalDirectBasis = {
    val cdb = new CanonicalDirectBasis
    cdb.copyValues(this)

    // Replace elements that are conclusion of binary imp with the premise of that imp
    // This generates the elements of the CDB that would have refinements in the D-basis
    val unrefined = binary flatMap {binImp =>
      nonBinary filter {nbImp =>
        binImp.conclusion.subsetOf(nbImp.premise) &&
        !binImp.premise.subsetOf(nbImp.conclusion) // keep if the conclusion of the binary imp is in the premise
      } map {nbImp =>
        val newPrem = (nbImp.premise &~ binImp.conclusion) | binImp.premise
        Implication(newPrem, nbImp.conclusion)
      }
    }

    cdb.basis = this.basis | unrefined
    cdb.basis =
      cdb.basis.filter(implication =>
        (cdb.basis - implication).forall(basisImp =>
          !(basisImp.premise.subsetOf(implication.premise) &&
          basisImp.conclusion.equals(implication.conclusion))
        )
      )
    cdb
  }

  /**
   * Parses a DBasis from the output of the hypergraph dualization algorithm
   */
  def fromHypergraphDualizationFile(fileLocation: String) = {
    val lines = scala.io.Source.fromFile(fileLocation).getLines

    lines.withFilter(_.matches("""\d\.\d\d.*->.*"""))
      .foreach{ line =>
        val strippedLine = line.replaceAll("""\d\.\d\d \d+;""", "").replaceAll(" ; .*", "")
        addImplication(
          parseImplication(strippedLine)
        )
      }

    generateBaseSet()
  }

  def withLogging(): LoggingBasis = {
    val newBasis = new DBasis with LoggingBasis
    newBasis.copyValues(this)
    newBasis
  }

}
