package basis

import cats.instances.set._

class DBasis extends Basis {

  override def update(newSet: Set[String]) = {
    super.update(newSet)
    val broken = this.brokenImplications(newSet)
    val unbroken = this.unbrokenImplications(newSet)
    val partialOrder = this.binary
    val nonBinaryPart = this.nonBinary
    val updatedPartialOrder = unbroken & partialOrder
    //println(s"New set: $newSet")
    //println(s"Broken: $broken")
    // Step 1: Calculate target set
    val targetSet = targets(partialOrder, newSet)
    //println(s"Targets: $targetSet")
    //println(s"Poset: $partialOrder")
    //println(s"newPoset: $updatedPartialOrder")
    //println(s"Non-binary with d=5: ${nonBinaryPart.filter(_.conclusion.contains("5"))}")
    // Step 2: Lift implications which contain elements of the target set
    val liftable = nonBinaryPart.filter(_.premise.intersect(targetSet).nonEmpty)
    //println(s"Liftable: $liftable")
    val lifted = liftable.flatMap(imp => lift(targetSet, partialOrder, newSet, imp))
    //println(s"Lifted to: $lifted")
    // Step 3: Check lifted implications for refinements
    val possibleRefinements = (updatedPartialOrder | nonBinaryPart | lifted).filter(_.premise.intersect(newSet).nonEmpty)
    val filteredLifted = filterRefinements(updatedPartialOrder, lifted, possibleRefinements)
    //println(s"Filtered to: $filteredLifted")
    // Step 4: Perform body-building formula on broken implications from original basis and lift
    val unbrokenLifted = filteredLifted.filter(_.holdsOn(newSet))
    //println(s"Unbroken lifted: $unbrokenLifted")
    val brokenLifted = filteredLifted &~ unbrokenLifted
    //println(s"Broken lifted: $brokenLifted")

    val updated: Set[Implication] = (broken | brokenLifted).flatMap { imp =>
      val ineligibleExtensions = newSet | upSet(updatedPartialOrder, imp.conclusion) // A union d_{uparrow A}
      val extensions = minimalElements(updatedPartialOrder, this.baseSet &~ ineligibleExtensions)
      extensions.map( ext =>
        extend(updatedPartialOrder, imp, Set(ext))
      )
    }
    //println(s"Updated to: $updated")

    // Step 5: Filter out possible refinements generated by body-building
    val filteredUpdatedAndLifted = filterRefinements(updatedPartialOrder, updated | unbrokenLifted, updated | unbroken | unbrokenLifted)
    //println(s"Update filtered to: $filteredUpdatedAndLifted")

    this.basis = filteredUpdatedAndLifted | unbroken
  }

  def targets(partialOrder: Set[Implication], newSet: Set[String]) =
    partialOrder.filterNot(_.holdsOn(newSet)).flatMap(_.conclusion) &~ newSet

  def lift(targetSet: Set[String], partialOrder: Set[Implication], newSet: Set[String], imp: Implication): Set[Implication] = {
    if (imp.premise.forall(elem => !targetSet.contains(elem))) // no element of C is in the target set
      Set(imp)
    else { // some element of C is in the target set
      val removableElements = imp.premise.intersect(targetSet)
      val remainingElements = imp.premise &~ removableElements
      // want all implications with at least one of these elements replaced
      val replacements = removableElements.map{ removable =>
        ((minStrictUpSet(partialOrder, newSet, Set(removable))) &~ imp.conclusion) + removable
      }
      val premises = product(replacements)
      val lifted = premises.map(prem => Implication(remainingElements | prem, imp.conclusion)) - imp // one combination will be original implication

      lifted.filter(_.holdsOn(newSet))
        .map(imp =>
          reducePremise(partialOrder.filter(_.holdsOn(newSet)), imp)
        )
    }
  }

  /** Implementation of A_x from paper. Finds the set of elements directly above x in the partial order */
  def minStrictUpSet(partialOrder: Set[Implication], newSet: Set[String], elements: Set[String]): Set[String] =
    minimalElements(partialOrder, (upSet(partialOrder, elements) &~ elements) & newSet)

  /** Filter out elements which are not minimal with respect to the partial order */
  def minimalElements(partialOrder: Set[Implication], elements: Set[String]) =
    elements.filterNot(elem1 =>
      (elements - elem1).exists(elem2 =>
        greaterThanOrEqualTo(partialOrder, Set(elem1), Set(elem2))
      )
    )

  /**
   * Reduces the premise of an implication with respect to the partial order.
   * If the premise contains x and y where x is in the order ideal of y,
   * then we can remove x from the premise to get a stronger implication
   */
  def reducePremise(partialOrder: Set[Implication], imp: Implication): Implication = {
    val reducedPremise =
      imp.premise.filterNot(x =>
        (imp.premise - x).exists(y =>
          ideal(partialOrder, Set(y)).contains(x)
        )
      )

    Implication(reducedPremise, imp.conclusion)
  }

  /** Returns a set containing A and all elements above A in the partial order */
  def upSet(partialOrder: Set[Implication], A: Set[String]): Set[String] =
    A | partialOrder.filter(_.conclusion.subsetOf(A))
                    .flatMap(_.premise)

  /** For sets x and y greaterThanOrEqualTo(x, y) is True if x -> y is in Sigma^b (binary) */
  def greaterThanOrEqualTo(partialOrder: Set[Implication], x: Set[String], y: Set[String]) =
    partialOrder.contains(Implication(x, y))

  def filterRefinements(partialOrder: Set[Implication], candidates: Set[Implication], existing: Set[Implication]) =
    candidates.filterNot( imp1 =>
      (existing - imp1).exists( imp2 =>
        refines(partialOrder, imp2, imp1)
      )
    )

  /** If imp1 << imp2, true otherwise false */
  def refines(partialOrder: Set[Implication], imp1: Implication, imp2: Implication): Boolean =
    if (imp1.conclusion.equals(imp2.conclusion))
      imp1.premise.subsetOf(imp2.premise | ideal(partialOrder, imp2.premise))
    else
      false

  def extend(partialOrder: Set[Implication], imp: Implication, ext: Set[String]) = {
    val extensionIdeal = ideal(partialOrder, ext)
    if (imp.premise.intersect(extensionIdeal).nonEmpty)
      Implication((imp.premise &~ extensionIdeal) | ext, imp.conclusion)
    else
      Implication(imp.premise | ext, imp.conclusion)
  }

  /**
   * Calculates the ideal of an element in the lattice. The ideal of a set A
   * consists of all elements in sets below A in the partial order
   */
  def ideal(partialOrder: Set[Implication], topSet: Set[String]): Set[String] = {
    val children = partialOrder.filter(_.premise.subsetOf(topSet))
                                 .flatMap(_.conclusion)

    if (children.subsetOf(topSet))
      topSet
    else
      ideal(partialOrder, topSet | children)
  }

  /* This is not entirely correct; produces incorrect CDB for some examples */
  def toCdb(): CanonicalDirectBasis = {
    val cdb = new CanonicalDirectBasis
    cdb.copyValues(this)

    // Replace elements that are conclusion of binary imp with the premise of that imp
    // This generates the elements of the CDB that would have refinements in the D-basis
    val unrefined = binary flatMap {binImp =>
      nonBinary filter {nbImp =>
        binImp.conclusion.subsetOf(nbImp.premise) &&
        !binImp.premise.subsetOf(nbImp.conclusion) // keep if the conclusion of the binary imp is in the premise
      } map {nbImp =>
        val newPrem = (nbImp.premise &~ binImp.conclusion) | binImp.premise
        Implication(newPrem, nbImp.conclusion)
      }
    }

    cdb.basis = this.basis | unrefined
    cdb.basis =
      cdb.basis.filter(implication =>
        (cdb.basis - implication).forall(basisImp =>
          !(basisImp.premise.subsetOf(implication.premise) &&
          basisImp.conclusion.equals(implication.conclusion))
        )
      )
    cdb
  }
}

object DBasis {
  def buildDBasis(table: Table): DBasis = table.buildBasis(new DBasis())
}
