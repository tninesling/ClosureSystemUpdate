package basis

import cats.instances.set._

class DBasis extends Basis {

  override def update(newSet: Set[String]) = {
    super.update(newSet)
    val broken = this.brokenImplications(newSet)
    val unbroken = this.unbrokenImplications(newSet)
    val partialOrder = this.binary
    val nonBinaryPart = this.nonBinary
    val updatedPartialOrder = unbroken & partialOrder

    // Step 1: Calculate target set
    val targetSet = targets(partialOrder, newSet)

    // Step 2: Lift implications which contain elements of the target set
    val liftable = nonBinaryPart.filter(_.premise.intersect(targetSet).nonEmpty)
    val lifted = liftable.flatMap(imp => lift(targetSet, partialOrder, newSet, imp))

    // Step 3: Check lifted implications for refinements
    val possibleRefinements = (updatedPartialOrder | nonBinaryPart | lifted).filter(_.premise.intersect(newSet).nonEmpty)
    val filteredLifted = filterRefinements(updatedPartialOrder, lifted, possibleRefinements)

    // Step 4: Perform body-building formula on broken implications from original basis and lift
    val unbrokenLifted = filteredLifted.filter(_.holdsOn(newSet))
    val brokenLifted = filteredLifted &~ unbrokenLifted

    val updated: Set[Implication] = (broken | brokenLifted).flatMap { imp =>
      val ineligibleExtensions = newSet | upSet(updatedPartialOrder, imp.conclusion) // A union d_{uparrow A}
      val extensions = minimalElements(updatedPartialOrder, this.baseSet &~ ineligibleExtensions)
      extensions.map( ext =>
        extend(updatedPartialOrder, imp, Set(ext))
      )
    }

    // Step 5: Filter out possible refinements generated by body-building
    val filteredUpdatedAndLifted = filterRefinements(updatedPartialOrder, updated | unbrokenLifted, updated | unbroken | unbrokenLifted)
    /*
    println(s"Liftable: $liftable")
    println(s"Lifted to: $lifted")
    println(s"Broken and broken lifted: ${broken | brokenLifted}")
    println(s"Body-built to: $updated")
    println(s"Refined to: $filteredUpdatedAndLifted")
    */
    this.basis = filteredUpdatedAndLifted | unbroken
  }

  override def handleEquivalence(newSet: Set[String])(e: Equivalence): Unit = {
    e match {
      case BinaryEquivalence(x, y) => {
        val expanded = e.expand(this.baseSet)

        val premOfBroken = newSet.intersect(x | y)
        val concOfBroken = (x | y) &~ newSet

        val replaceable = this.basis.filter(imp => premOfBroken.subsetOf(imp.premise))

        val additionalImps =
          replaceable.map { case Implication(left, right) =>
            Implication(left.diff(premOfBroken).union(concOfBroken), right)
          }

        this.basis =
          this.basis
            .diff(replaceable)
            .union(additionalImps + Implication(concOfBroken, premOfBroken))
      }
      case AllEquivalence(y) => {
        this.baseSet = this.baseSet | y
        this.basis = this.basis | e.expand(this.baseSet)
      }
      case NonbinaryEquivalence(_,_) => {
        this.basis = this.basis | e.expand(this.baseSet)
      }
    }
  }
/*
  override def handleBinaryEquivalences(newSet: Set[String]) = {
    super.handleBinaryEquivalences(newSet)

    val affectedBinaryEquivs =
      this.affectedEquivalences(newSet).filter(x =>
        (x.premise.size == 1) && (x.conclusion.size == 1)
      )
    val binaryUnbrokenEquivs = affectedBinaryEquivs.filter(_.holdsOn(newSet))
    val binaryBrokenEquivs = affectedBinaryEquivs.filterNot(_.holdsOn(newSet))

    // For the unbroken binary parts, simply add them to the basis
    this.basis = this.basis | binaryUnbrokenEquivs

    // For each broken binary implication x -> y, replace all instances of y with x
    binaryBrokenEquivs.foreach { imp =>
      val affected = this.basis.filter(x => imp.premise.subsetOf(x.premise))
      val refined = affected.map { affectedImp =>
        val newPremise = affectedImp.premise.diff(imp.premise).union(imp.conclusion)

        Implication(newPremise, affectedImp.conclusion)
      }

      this.basis = this.basis.diff(affected).union(refined)
    }
  }*/

  def targets(partialOrder: Set[Implication], newSet: Set[String]) =
    partialOrder.filterNot(_.holdsOn(newSet)).flatMap(_.conclusion) &~ newSet

  def lift(targetSet: Set[String], partialOrder: Set[Implication], newSet: Set[String], imp: Implication): Set[Implication] = {
    if (imp.premise.forall(elem => !targetSet.contains(elem))) // no element of C is in the target set
      Set(imp)
    else { // some element of C is in the target set
      val removableElements = imp.premise.intersect(targetSet)
      val remainingElements = imp.premise &~ removableElements
      // want all implications with at least one of these elements replaced
      val replacements = removableElements.map{ removable =>
        ((minStrictUpSet(partialOrder, newSet, Set(removable))) &~ imp.conclusion) + removable
      }
      val premises = product(replacements)
      val lifted = premises.map(prem => Implication(remainingElements | prem, imp.conclusion)) - imp // one combination will be original implication

      lifted.filter(_.holdsOn(newSet))
        .map(imp =>
          reducePremise(partialOrder.filter(_.holdsOn(newSet)), imp)
        )
    }
  }

  /** Implementation of A_x from paper. Finds the set of elements directly above x in the partial order */
  def minStrictUpSet(partialOrder: Set[Implication], newSet: Set[String], elements: Set[String]): Set[String] =
    minimalElements(partialOrder, (upSet(partialOrder, elements) &~ elements) & newSet)

  /** Filter out elements which are not minimal with respect to the partial order */
  def minimalElements(partialOrder: Set[Implication], elements: Set[String]) =
    elements.filterNot(elem1 =>
      (elements - elem1).exists(elem2 =>
        greaterThanOrEqualTo(partialOrder, Set(elem1), Set(elem2))
      )
    )

  /**
   * Reduces the premise of an implication with respect to the partial order.
   * If the premise contains x and y where x is in the order ideal of y,
   * then we can remove x from the premise to get a stronger implication
   */
  def reducePremise(partialOrder: Set[Implication], imp: Implication): Implication = {
    val reducedPremise =
      imp.premise.filterNot(x =>
        (imp.premise - x).exists(y =>
          ideal(partialOrder, Set(y)).contains(x)
        )
      )

    Implication(reducedPremise, imp.conclusion)
  }

  /** Returns a set containing A and all elements above A in the partial order */
  def upSet(partialOrder: Set[Implication], A: Set[String]): Set[String] =
    A | partialOrder.filter(_.conclusion.subsetOf(A))
                    .flatMap(_.premise)

  /** For sets x and y greaterThanOrEqualTo(x, y) is True if x -> y is in Sigma^b (binary) */
  def greaterThanOrEqualTo(partialOrder: Set[Implication], x: Set[String], y: Set[String]) =
    partialOrder.contains(Implication(x, y))

  def filterRefinements(partialOrder: Set[Implication], candidates: Set[Implication], existing: Set[Implication]) =
    candidates.filterNot( imp1 =>
      (existing - imp1).exists(imp2 =>
        refines(partialOrder, imp2, imp1)
      )
    )

  /** If imp1 << imp2, true otherwise false */
  def refines(partialOrder: Set[Implication], imp1: Implication, imp2: Implication): Boolean =
    if (imp1.conclusion.equals(imp2.conclusion))
      imp1.premise.subsetOf(imp2.premise | ideal(partialOrder, imp2.premise))
    else
      false

  def extend(partialOrder: Set[Implication], imp: Implication, ext: Set[String]) = {
    val extensionIdeal = ideal(partialOrder, ext)
    if (imp.premise.intersect(extensionIdeal).nonEmpty)
      Implication((imp.premise &~ extensionIdeal) | ext, imp.conclusion)
    else
      Implication(imp.premise | ext, imp.conclusion)
  }

  /**
   * Calculates the ideal of an element in the lattice. The ideal of a set A
   * consists of all elements in sets below A in the partial order
   */
  def ideal(partialOrder: Set[Implication], topSet: Set[String]): Set[String] = {
    val children = partialOrder.filter(_.premise.subsetOf(topSet))
                               .flatMap(_.conclusion)

    if (children.subsetOf(topSet))
      topSet
    else
      ideal(partialOrder, topSet | children)
  }

  /* This is not entirely correct; produces incorrect CDB for some examples */
  def toCdb(): CanonicalDirectBasis = {
    val cdb = new CanonicalDirectBasis
    cdb.copy(this)

    // Replace elements that are conclusion of binary imp with the premise of that imp
    // This generates the elements of the CDB that would have refinements in the D-basis
    val unrefined = binary flatMap {binImp =>
      nonBinary filter {nbImp =>
        binImp.conclusion.subsetOf(nbImp.premise) &&
        !binImp.premise.subsetOf(nbImp.conclusion) // keep if the conclusion of the binary imp is in the premise
      } map {nbImp =>
        val newPrem = (nbImp.premise &~ binImp.conclusion) | binImp.premise
        Implication(newPrem, nbImp.conclusion)
      }
    }

    cdb.basis = this.basis | unrefined
    cdb.basis =
      cdb.basis.filter(implication =>
        (cdb.basis - implication).forall(basisImp =>
          !(basisImp.premise.subsetOf(implication.premise) &&
          basisImp.conclusion.equals(implication.conclusion))
        )
      )
    cdb
  }
}
